{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, writeTask, readTask, h, Host } from '@stencil/core/internal/client';\nimport { b as getIonMode } from './ionic-global.js';\nimport { a as findClosestIonContent, p as printIonContentErrorMsg, g as getScrollElement } from './index8.js';\nconst infiniteScrollCss = \"ion-infinite-scroll{display:none;width:100%}.infinite-scroll-enabled{display:block}\";\nconst InfiniteScroll = /*@__PURE__*/proxyCustomElement(class InfiniteScroll extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionInfinite = createEvent(this, \"ionInfinite\", 7);\n    this.thrPx = 0;\n    this.thrPc = 0;\n    this.didFire = false;\n    this.isBusy = false;\n    this.onScroll = () => {\n      const scrollEl = this.scrollEl;\n      if (!scrollEl || !this.canStart()) {\n        return 1;\n      }\n      const infiniteHeight = this.el.offsetHeight;\n      if (infiniteHeight === 0) {\n        // if there is no height of this element then do nothing\n        return 2;\n      }\n      const scrollTop = scrollEl.scrollTop;\n      const scrollHeight = scrollEl.scrollHeight;\n      const height = scrollEl.offsetHeight;\n      const threshold = this.thrPc !== 0 ? height * this.thrPc : this.thrPx;\n      const distanceFromInfinite = this.position === 'bottom' ? scrollHeight - infiniteHeight - scrollTop - threshold - height : scrollTop - infiniteHeight - threshold;\n      if (distanceFromInfinite < 0) {\n        if (!this.didFire) {\n          this.isLoading = true;\n          this.didFire = true;\n          this.ionInfinite.emit();\n          return 3;\n        }\n      } else {\n        this.didFire = false;\n      }\n      return 4;\n    };\n    this.isLoading = false;\n    this.threshold = '15%';\n    this.disabled = false;\n    this.position = 'bottom';\n  }\n  thresholdChanged() {\n    const val = this.threshold;\n    if (val.lastIndexOf('%') > -1) {\n      this.thrPx = 0;\n      this.thrPc = parseFloat(val) / 100;\n    } else {\n      this.thrPx = parseFloat(val);\n      this.thrPc = 0;\n    }\n  }\n  disabledChanged() {\n    const disabled = this.disabled;\n    if (disabled) {\n      this.isLoading = false;\n      this.isBusy = false;\n    }\n    this.enableScrollEvents(!disabled);\n  }\n  async connectedCallback() {\n    const contentEl = findClosestIonContent(this.el);\n    if (!contentEl) {\n      printIonContentErrorMsg(this.el);\n      return;\n    }\n    this.scrollEl = await getScrollElement(contentEl);\n    this.thresholdChanged();\n    this.disabledChanged();\n    if (this.position === 'top') {\n      writeTask(() => {\n        if (this.scrollEl) {\n          this.scrollEl.scrollTop = this.scrollEl.scrollHeight - this.scrollEl.clientHeight;\n        }\n      });\n    }\n  }\n  disconnectedCallback() {\n    this.enableScrollEvents(false);\n    this.scrollEl = undefined;\n  }\n  /**\n   * Call `complete()` within the `ionInfinite` output event handler when\n   * your async operation has completed. For example, the `loading`\n   * state is while the app is performing an asynchronous operation,\n   * such as receiving more data from an AJAX request to add more items\n   * to a data list. Once the data has been received and UI updated, you\n   * then call this method to signify that the loading has completed.\n   * This method will change the infinite scroll's state from `loading`\n   * to `enabled`.\n   */\n  async complete() {\n    const scrollEl = this.scrollEl;\n    if (!this.isLoading || !scrollEl) {\n      return;\n    }\n    this.isLoading = false;\n    if (this.position === 'top') {\n      /**\n       * New content is being added at the top, but the scrollTop position stays the same,\n       * which causes a scroll jump visually. This algorithm makes sure to prevent this.\n       * (Frame 1)\n       *    - complete() is called, but the UI hasn't had time to update yet.\n       *    - Save the current content dimensions.\n       *    - Wait for the next frame using _dom.read, so the UI will be updated.\n       * (Frame 2)\n       *    - Read the new content dimensions.\n       *    - Calculate the height difference and the new scroll position.\n       *    - Delay the scroll position change until other possible dom reads are done using _dom.write to be performant.\n       * (Still frame 2, if I'm correct)\n       *    - Change the scroll position (= visually maintain the scroll position).\n       *    - Change the state to re-enable the InfiniteScroll.\n       *    - This should be after changing the scroll position, or it could\n       *    cause the InfiniteScroll to be triggered again immediately.\n       * (Frame 3)\n       *    Done.\n       */\n      this.isBusy = true;\n      // ******** DOM READ ****************\n      // Save the current content dimensions before the UI updates\n      const prev = scrollEl.scrollHeight - scrollEl.scrollTop;\n      // ******** DOM READ ****************\n      requestAnimationFrame(() => {\n        readTask(() => {\n          // UI has updated, save the new content dimensions\n          const scrollHeight = scrollEl.scrollHeight;\n          // New content was added on top, so the scroll position should be changed immediately to prevent it from jumping around\n          const newScrollTop = scrollHeight - prev;\n          // ******** DOM WRITE ****************\n          requestAnimationFrame(() => {\n            writeTask(() => {\n              scrollEl.scrollTop = newScrollTop;\n              this.isBusy = false;\n            });\n          });\n        });\n      });\n    }\n  }\n  canStart() {\n    return !this.disabled && !this.isBusy && !!this.scrollEl && !this.isLoading;\n  }\n  enableScrollEvents(shouldListen) {\n    if (this.scrollEl) {\n      if (shouldListen) {\n        this.scrollEl.addEventListener('scroll', this.onScroll);\n      } else {\n        this.scrollEl.removeEventListener('scroll', this.onScroll);\n      }\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    const disabled = this.disabled;\n    return h(Host, {\n      class: {\n        [mode]: true,\n        'infinite-scroll-loading': this.isLoading,\n        'infinite-scroll-enabled': !disabled\n      }\n    });\n  }\n  get el() {\n    return this;\n  }\n  static get watchers() {\n    return {\n      \"threshold\": [\"thresholdChanged\"],\n      \"disabled\": [\"disabledChanged\"]\n    };\n  }\n  static get style() {\n    return infiniteScrollCss;\n  }\n}, [0, \"ion-infinite-scroll\", {\n  \"threshold\": [1],\n  \"disabled\": [4],\n  \"position\": [1],\n  \"isLoading\": [32],\n  \"complete\": [64]\n}]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-infinite-scroll\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"ion-infinite-scroll\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, InfiniteScroll);\n        }\n        break;\n    }\n  });\n}\nconst IonInfiniteScroll = InfiniteScroll;\nconst defineCustomElement = defineCustomElement$1;\nexport { IonInfiniteScroll, defineCustomElement };","map":{"version":3,"names":["proxyCustomElement","HTMLElement","createEvent","writeTask","readTask","h","Host","b","getIonMode","a","findClosestIonContent","p","printIonContentErrorMsg","g","getScrollElement","infiniteScrollCss","InfiniteScroll","constructor","__registerHost","ionInfinite","thrPx","thrPc","didFire","isBusy","onScroll","scrollEl","canStart","infiniteHeight","el","offsetHeight","scrollTop","scrollHeight","height","threshold","distanceFromInfinite","position","isLoading","emit","disabled","thresholdChanged","val","lastIndexOf","parseFloat","disabledChanged","enableScrollEvents","connectedCallback","contentEl","clientHeight","disconnectedCallback","undefined","complete","prev","requestAnimationFrame","newScrollTop","shouldListen","addEventListener","removeEventListener","render","mode","class","watchers","style","defineCustomElement$1","customElements","components","forEach","tagName","get","define","IonInfiniteScroll","defineCustomElement"],"sources":["C:/Users/EdinÃ©ia/Documents/NutriFood/node_modules/@ionic/core/components/ion-infinite-scroll.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, writeTask, readTask, h, Host } from '@stencil/core/internal/client';\nimport { b as getIonMode } from './ionic-global.js';\nimport { a as findClosestIonContent, p as printIonContentErrorMsg, g as getScrollElement } from './index8.js';\n\nconst infiniteScrollCss = \"ion-infinite-scroll{display:none;width:100%}.infinite-scroll-enabled{display:block}\";\n\nconst InfiniteScroll = /*@__PURE__*/ proxyCustomElement(class InfiniteScroll extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionInfinite = createEvent(this, \"ionInfinite\", 7);\n    this.thrPx = 0;\n    this.thrPc = 0;\n    this.didFire = false;\n    this.isBusy = false;\n    this.onScroll = () => {\n      const scrollEl = this.scrollEl;\n      if (!scrollEl || !this.canStart()) {\n        return 1;\n      }\n      const infiniteHeight = this.el.offsetHeight;\n      if (infiniteHeight === 0) {\n        // if there is no height of this element then do nothing\n        return 2;\n      }\n      const scrollTop = scrollEl.scrollTop;\n      const scrollHeight = scrollEl.scrollHeight;\n      const height = scrollEl.offsetHeight;\n      const threshold = this.thrPc !== 0 ? height * this.thrPc : this.thrPx;\n      const distanceFromInfinite = this.position === 'bottom'\n        ? scrollHeight - infiniteHeight - scrollTop - threshold - height\n        : scrollTop - infiniteHeight - threshold;\n      if (distanceFromInfinite < 0) {\n        if (!this.didFire) {\n          this.isLoading = true;\n          this.didFire = true;\n          this.ionInfinite.emit();\n          return 3;\n        }\n      }\n      else {\n        this.didFire = false;\n      }\n      return 4;\n    };\n    this.isLoading = false;\n    this.threshold = '15%';\n    this.disabled = false;\n    this.position = 'bottom';\n  }\n  thresholdChanged() {\n    const val = this.threshold;\n    if (val.lastIndexOf('%') > -1) {\n      this.thrPx = 0;\n      this.thrPc = parseFloat(val) / 100;\n    }\n    else {\n      this.thrPx = parseFloat(val);\n      this.thrPc = 0;\n    }\n  }\n  disabledChanged() {\n    const disabled = this.disabled;\n    if (disabled) {\n      this.isLoading = false;\n      this.isBusy = false;\n    }\n    this.enableScrollEvents(!disabled);\n  }\n  async connectedCallback() {\n    const contentEl = findClosestIonContent(this.el);\n    if (!contentEl) {\n      printIonContentErrorMsg(this.el);\n      return;\n    }\n    this.scrollEl = await getScrollElement(contentEl);\n    this.thresholdChanged();\n    this.disabledChanged();\n    if (this.position === 'top') {\n      writeTask(() => {\n        if (this.scrollEl) {\n          this.scrollEl.scrollTop = this.scrollEl.scrollHeight - this.scrollEl.clientHeight;\n        }\n      });\n    }\n  }\n  disconnectedCallback() {\n    this.enableScrollEvents(false);\n    this.scrollEl = undefined;\n  }\n  /**\n   * Call `complete()` within the `ionInfinite` output event handler when\n   * your async operation has completed. For example, the `loading`\n   * state is while the app is performing an asynchronous operation,\n   * such as receiving more data from an AJAX request to add more items\n   * to a data list. Once the data has been received and UI updated, you\n   * then call this method to signify that the loading has completed.\n   * This method will change the infinite scroll's state from `loading`\n   * to `enabled`.\n   */\n  async complete() {\n    const scrollEl = this.scrollEl;\n    if (!this.isLoading || !scrollEl) {\n      return;\n    }\n    this.isLoading = false;\n    if (this.position === 'top') {\n      /**\n       * New content is being added at the top, but the scrollTop position stays the same,\n       * which causes a scroll jump visually. This algorithm makes sure to prevent this.\n       * (Frame 1)\n       *    - complete() is called, but the UI hasn't had time to update yet.\n       *    - Save the current content dimensions.\n       *    - Wait for the next frame using _dom.read, so the UI will be updated.\n       * (Frame 2)\n       *    - Read the new content dimensions.\n       *    - Calculate the height difference and the new scroll position.\n       *    - Delay the scroll position change until other possible dom reads are done using _dom.write to be performant.\n       * (Still frame 2, if I'm correct)\n       *    - Change the scroll position (= visually maintain the scroll position).\n       *    - Change the state to re-enable the InfiniteScroll.\n       *    - This should be after changing the scroll position, or it could\n       *    cause the InfiniteScroll to be triggered again immediately.\n       * (Frame 3)\n       *    Done.\n       */\n      this.isBusy = true;\n      // ******** DOM READ ****************\n      // Save the current content dimensions before the UI updates\n      const prev = scrollEl.scrollHeight - scrollEl.scrollTop;\n      // ******** DOM READ ****************\n      requestAnimationFrame(() => {\n        readTask(() => {\n          // UI has updated, save the new content dimensions\n          const scrollHeight = scrollEl.scrollHeight;\n          // New content was added on top, so the scroll position should be changed immediately to prevent it from jumping around\n          const newScrollTop = scrollHeight - prev;\n          // ******** DOM WRITE ****************\n          requestAnimationFrame(() => {\n            writeTask(() => {\n              scrollEl.scrollTop = newScrollTop;\n              this.isBusy = false;\n            });\n          });\n        });\n      });\n    }\n  }\n  canStart() {\n    return !this.disabled && !this.isBusy && !!this.scrollEl && !this.isLoading;\n  }\n  enableScrollEvents(shouldListen) {\n    if (this.scrollEl) {\n      if (shouldListen) {\n        this.scrollEl.addEventListener('scroll', this.onScroll);\n      }\n      else {\n        this.scrollEl.removeEventListener('scroll', this.onScroll);\n      }\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    const disabled = this.disabled;\n    return (h(Host, { class: {\n        [mode]: true,\n        'infinite-scroll-loading': this.isLoading,\n        'infinite-scroll-enabled': !disabled,\n      } }));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"threshold\": [\"thresholdChanged\"],\n    \"disabled\": [\"disabledChanged\"]\n  }; }\n  static get style() { return infiniteScrollCss; }\n}, [0, \"ion-infinite-scroll\", {\n    \"threshold\": [1],\n    \"disabled\": [4],\n    \"position\": [1],\n    \"isLoading\": [32],\n    \"complete\": [64]\n  }]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-infinite-scroll\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-infinite-scroll\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, InfiniteScroll);\n      }\n      break;\n  } });\n}\n\nconst IonInfiniteScroll = InfiniteScroll;\nconst defineCustomElement = defineCustomElement$1;\n\nexport { IonInfiniteScroll, defineCustomElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}