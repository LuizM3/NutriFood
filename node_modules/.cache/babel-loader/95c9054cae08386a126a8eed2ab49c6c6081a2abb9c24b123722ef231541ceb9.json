{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';\nimport { w as watchForOptions } from './watch-options.js';\nimport { b as getIonMode } from './ionic-global.js';\nimport { a as findClosestIonContent, d as disableContentScrollY, r as resetContentScrollY } from './index8.js';\nimport { o as isEndSide } from './helpers.js';\nconst itemSlidingCss = \"ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item-sliding .item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.item-sliding-active-slide .item{position:relative;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;-ms-flex-order:1;order:1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-left;transition-property:padding-left}:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-end .item-options-end .item-option-expandable:dir(rtl){-ms-flex-order:-1;order:-1}}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;-ms-flex-order:-1;order:-1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-right;transition-property:padding-right}:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-start .item-options-start .item-option-expandable:dir(rtl){-ms-flex-order:1;order:1}}\";\nconst SWIPE_MARGIN = 30;\nconst ELASTIC_FACTOR = 0.55;\nlet openSlidingItem;\nconst ItemSliding = /*@__PURE__*/proxyCustomElement(class ItemSliding extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionDrag = createEvent(this, \"ionDrag\", 7);\n    this.item = null;\n    this.openAmount = 0;\n    this.initialOpenAmount = 0;\n    this.optsWidthRightSide = 0;\n    this.optsWidthLeftSide = 0;\n    this.sides = 0 /* ItemSide.None */;\n    this.optsDirty = true;\n    this.contentEl = null;\n    this.initialContentScrollY = true;\n    this.state = 2 /* SlidingState.Disabled */;\n    this.disabled = false;\n  }\n  disabledChanged() {\n    if (this.gesture) {\n      this.gesture.enable(!this.disabled);\n    }\n  }\n  async connectedCallback() {\n    const {\n      el\n    } = this;\n    this.item = el.querySelector('ion-item');\n    this.contentEl = findClosestIonContent(el);\n    await this.updateOptions();\n    this.mutationObserver = watchForOptions(el, 'ion-item-option', async () => {\n      await this.updateOptions();\n    });\n    this.gesture = (await import('./index2.js')).createGesture({\n      el,\n      gestureName: 'item-swipe',\n      gesturePriority: 100,\n      threshold: 5,\n      canStart: ev => this.canStart(ev),\n      onStart: () => this.onStart(),\n      onMove: ev => this.onMove(ev),\n      onEnd: ev => this.onEnd(ev)\n    });\n    this.disabledChanged();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n    this.item = null;\n    this.leftOptions = this.rightOptions = undefined;\n    if (openSlidingItem === this.el) {\n      openSlidingItem = undefined;\n    }\n    if (this.mutationObserver) {\n      this.mutationObserver.disconnect();\n      this.mutationObserver = undefined;\n    }\n  }\n  /**\n   * Get the amount the item is open in pixels.\n   */\n  getOpenAmount() {\n    return Promise.resolve(this.openAmount);\n  }\n  /**\n   * Get the ratio of the open amount of the item compared to the width of the options.\n   * If the number returned is positive, then the options on the right side are open.\n   * If the number returned is negative, then the options on the left side are open.\n   * If the absolute value of the number is greater than 1, the item is open more than\n   * the width of the options.\n   */\n  getSlidingRatio() {\n    return Promise.resolve(this.getSlidingRatioSync());\n  }\n  /**\n   * Open the sliding item.\n   *\n   * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.\n   */\n  async open(side) {\n    var _a;\n    /**\n     * It is possible for the item to be added to the DOM\n     * after the item-sliding component was created. As a result,\n     * if this.item is null, then we should attempt to\n     * query for the ion-item again.\n     * However, if the item is already defined then\n     * we do not query for it again.\n     */\n    const item = this.item = (_a = this.item) !== null && _a !== void 0 ? _a : this.el.querySelector('ion-item');\n    if (item === null) {\n      return;\n    }\n    const optionsToOpen = this.getOptions(side);\n    if (!optionsToOpen) {\n      return;\n    }\n    /**\n     * If side is not set, we need to infer the side\n     * so we know which direction to move the options\n     */\n    if (side === undefined) {\n      side = optionsToOpen === this.leftOptions ? 'start' : 'end';\n    }\n    // In RTL we want to switch the sides\n    side = isEndSide(side) ? 'end' : 'start';\n    const isStartOpen = this.openAmount < 0;\n    const isEndOpen = this.openAmount > 0;\n    /**\n     * If a side is open and a user tries to\n     * re-open the same side, we should not do anything\n     */\n    if (isStartOpen && optionsToOpen === this.leftOptions) {\n      return;\n    }\n    if (isEndOpen && optionsToOpen === this.rightOptions) {\n      return;\n    }\n    this.closeOpened();\n    this.state = 4 /* SlidingState.Enabled */;\n    requestAnimationFrame(() => {\n      this.calculateOptsWidth();\n      const width = side === 'end' ? this.optsWidthRightSide : -this.optsWidthLeftSide;\n      openSlidingItem = this.el;\n      this.setOpenAmount(width, false);\n      this.state = side === 'end' ? 8 /* SlidingState.End */ : 16 /* SlidingState.Start */;\n    });\n  }\n  /**\n   * Close the sliding item. Items can also be closed from the [List](./list).\n   */\n  async close() {\n    this.setOpenAmount(0, true);\n  }\n  /**\n   * Close all of the sliding items in the list. Items can also be closed from the [List](./list).\n   */\n  async closeOpened() {\n    if (openSlidingItem !== undefined) {\n      openSlidingItem.close();\n      openSlidingItem = undefined;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Given an optional side, return the ion-item-options element.\n   *\n   * @param side This side of the options to get. If a side is not provided it will\n   * return the first one available.\n   */\n  getOptions(side) {\n    if (side === undefined) {\n      return this.leftOptions || this.rightOptions;\n    } else if (side === 'start') {\n      return this.leftOptions;\n    } else {\n      return this.rightOptions;\n    }\n  }\n  async updateOptions() {\n    const options = this.el.querySelectorAll('ion-item-options');\n    let sides = 0;\n    // Reset left and right options in case they were removed\n    this.leftOptions = this.rightOptions = undefined;\n    for (let i = 0; i < options.length; i++) {\n      const item = options.item(i);\n      /**\n       * We cannot use the componentOnReady helper\n       * util here since we need to wait for all of these items\n       * to be ready before we set `this.sides` and `this.optsDirty`.\n       */\n      // eslint-disable-next-line custom-rules/no-component-on-ready-method\n      const option = item.componentOnReady !== undefined ? await item.componentOnReady() : item;\n      const side = isEndSide(option.side) ? 'end' : 'start';\n      if (side === 'start') {\n        this.leftOptions = option;\n        sides |= 1 /* ItemSide.Start */;\n      } else {\n        this.rightOptions = option;\n        sides |= 2 /* ItemSide.End */;\n      }\n    }\n\n    this.optsDirty = true;\n    this.sides = sides;\n  }\n  canStart(gesture) {\n    /**\n     * If very close to start of the screen\n     * do not open left side so swipe to go\n     * back will still work.\n     */\n    const rtl = document.dir === 'rtl';\n    const atEdge = rtl ? window.innerWidth - gesture.startX < 15 : gesture.startX < 15;\n    if (atEdge) {\n      return false;\n    }\n    const selected = openSlidingItem;\n    if (selected && selected !== this.el) {\n      this.closeOpened();\n    }\n    return !!(this.rightOptions || this.leftOptions);\n  }\n  onStart() {\n    /**\n     * We need to query for the ion-item\n     * every time the gesture starts. Developers\n     * may toggle ion-item elements via *ngIf.\n     */\n    this.item = this.el.querySelector('ion-item');\n    const {\n      contentEl\n    } = this;\n    if (contentEl) {\n      this.initialContentScrollY = disableContentScrollY(contentEl);\n    }\n    openSlidingItem = this.el;\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (this.openAmount === 0) {\n      this.optsDirty = true;\n      this.state = 4 /* SlidingState.Enabled */;\n    }\n\n    this.initialOpenAmount = this.openAmount;\n    if (this.item) {\n      this.item.style.transition = 'none';\n    }\n  }\n  onMove(gesture) {\n    if (this.optsDirty) {\n      this.calculateOptsWidth();\n    }\n    let openAmount = this.initialOpenAmount - gesture.deltaX;\n    switch (this.sides) {\n      case 2 /* ItemSide.End */:\n        openAmount = Math.max(0, openAmount);\n        break;\n      case 1 /* ItemSide.Start */:\n        openAmount = Math.min(0, openAmount);\n        break;\n      case 3 /* ItemSide.Both */:\n        break;\n      case 0 /* ItemSide.None */:\n        return;\n      default:\n        console.warn('invalid ItemSideFlags value', this.sides);\n        break;\n    }\n    let optsWidth;\n    if (openAmount > this.optsWidthRightSide) {\n      optsWidth = this.optsWidthRightSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    } else if (openAmount < -this.optsWidthLeftSide) {\n      optsWidth = -this.optsWidthLeftSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    }\n    this.setOpenAmount(openAmount, false);\n  }\n  onEnd(gesture) {\n    const {\n      contentEl,\n      initialContentScrollY\n    } = this;\n    if (contentEl) {\n      resetContentScrollY(contentEl, initialContentScrollY);\n    }\n    const velocity = gesture.velocityX;\n    let restingPoint = this.openAmount > 0 ? this.optsWidthRightSide : -this.optsWidthLeftSide;\n    // Check if the drag didn't clear the buttons mid-point\n    // and we aren't moving fast enough to swipe open\n    const isResetDirection = this.openAmount > 0 === !(velocity < 0);\n    const isMovingFast = Math.abs(velocity) > 0.3;\n    const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);\n    if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {\n      restingPoint = 0;\n    }\n    const state = this.state;\n    this.setOpenAmount(restingPoint, true);\n    if ((state & 32 /* SlidingState.SwipeEnd */) !== 0 && this.rightOptions) {\n      this.rightOptions.fireSwipeEvent();\n    } else if ((state & 64 /* SlidingState.SwipeStart */) !== 0 && this.leftOptions) {\n      this.leftOptions.fireSwipeEvent();\n    }\n  }\n  calculateOptsWidth() {\n    this.optsWidthRightSide = 0;\n    if (this.rightOptions) {\n      this.rightOptions.style.display = 'flex';\n      this.optsWidthRightSide = this.rightOptions.offsetWidth;\n      this.rightOptions.style.display = '';\n    }\n    this.optsWidthLeftSide = 0;\n    if (this.leftOptions) {\n      this.leftOptions.style.display = 'flex';\n      this.optsWidthLeftSide = this.leftOptions.offsetWidth;\n      this.leftOptions.style.display = '';\n    }\n    this.optsDirty = false;\n  }\n  setOpenAmount(openAmount, isFinal) {\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (!this.item) {\n      return;\n    }\n    const style = this.item.style;\n    this.openAmount = openAmount;\n    if (isFinal) {\n      style.transition = '';\n    }\n    if (openAmount > 0) {\n      this.state = openAmount >= this.optsWidthRightSide + SWIPE_MARGIN ? 8 /* SlidingState.End */ | 32 /* SlidingState.SwipeEnd */ : 8 /* SlidingState.End */;\n    } else if (openAmount < 0) {\n      this.state = openAmount <= -this.optsWidthLeftSide - SWIPE_MARGIN ? 16 /* SlidingState.Start */ | 64 /* SlidingState.SwipeStart */ : 16 /* SlidingState.Start */;\n    } else {\n      /**\n       * Item sliding cannot be interrupted\n       * while closing the item. If it did,\n       * it would allow the item to get into an\n       * inconsistent state where multiple\n       * items are then open at the same time.\n       */\n      if (this.gesture) {\n        this.gesture.enable(false);\n      }\n      this.tmr = setTimeout(() => {\n        this.state = 2 /* SlidingState.Disabled */;\n        this.tmr = undefined;\n        if (this.gesture) {\n          this.gesture.enable(!this.disabled);\n        }\n      }, 600);\n      openSlidingItem = undefined;\n      style.transform = '';\n      return;\n    }\n    style.transform = `translate3d(${-openAmount}px,0,0)`;\n    this.ionDrag.emit({\n      amount: openAmount,\n      ratio: this.getSlidingRatioSync()\n    });\n  }\n  getSlidingRatioSync() {\n    if (this.openAmount > 0) {\n      return this.openAmount / this.optsWidthRightSide;\n    } else if (this.openAmount < 0) {\n      return this.openAmount / this.optsWidthLeftSide;\n    } else {\n      return 0;\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    return h(Host, {\n      class: {\n        [mode]: true,\n        'item-sliding-active-slide': this.state !== 2 /* SlidingState.Disabled */,\n        'item-sliding-active-options-end': (this.state & 8 /* SlidingState.End */) !== 0,\n        'item-sliding-active-options-start': (this.state & 16 /* SlidingState.Start */) !== 0,\n        'item-sliding-active-swipe-end': (this.state & 32 /* SlidingState.SwipeEnd */) !== 0,\n        'item-sliding-active-swipe-start': (this.state & 64 /* SlidingState.SwipeStart */) !== 0\n      }\n    });\n  }\n  get el() {\n    return this;\n  }\n  static get watchers() {\n    return {\n      \"disabled\": [\"disabledChanged\"]\n    };\n  }\n  static get style() {\n    return itemSlidingCss;\n  }\n}, [0, \"ion-item-sliding\", {\n  \"disabled\": [4],\n  \"state\": [32],\n  \"getOpenAmount\": [64],\n  \"getSlidingRatio\": [64],\n  \"open\": [64],\n  \"close\": [64],\n  \"closeOpened\": [64]\n}]);\nconst swipeShouldReset = (isResetDirection, isMovingFast, isOnResetZone) => {\n  // The logic required to know when the sliding item should close (openAmount=0)\n  // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)\n  // and it ended up being too complicated to be written manually without errors\n  // so the truth table is attached below: (0=false, 1=true)\n  // isResetDirection | isMovingFast | isOnResetZone || shouldClose\n  //         0        |       0      |       0       ||    0\n  //         0        |       0      |       1       ||    1\n  //         0        |       1      |       0       ||    0\n  //         0        |       1      |       1       ||    0\n  //         1        |       0      |       0       ||    0\n  //         1        |       0      |       1       ||    1\n  //         1        |       1      |       0       ||    1\n  //         1        |       1      |       1       ||    1\n  // The resulting expression was generated by resolving the K-map (Karnaugh map):\n  return !isMovingFast && isOnResetZone || isResetDirection && isMovingFast;\n};\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-item-sliding\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"ion-item-sliding\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, ItemSliding);\n        }\n        break;\n    }\n  });\n}\nconst IonItemSliding = ItemSliding;\nconst defineCustomElement = defineCustomElement$1;\nexport { IonItemSliding, defineCustomElement };","map":{"version":3,"names":["proxyCustomElement","HTMLElement","createEvent","h","Host","w","watchForOptions","b","getIonMode","a","findClosestIonContent","d","disableContentScrollY","r","resetContentScrollY","o","isEndSide","itemSlidingCss","SWIPE_MARGIN","ELASTIC_FACTOR","openSlidingItem","ItemSliding","constructor","__registerHost","ionDrag","item","openAmount","initialOpenAmount","optsWidthRightSide","optsWidthLeftSide","sides","optsDirty","contentEl","initialContentScrollY","state","disabled","disabledChanged","gesture","enable","connectedCallback","el","querySelector","updateOptions","mutationObserver","createGesture","gestureName","gesturePriority","threshold","canStart","ev","onStart","onMove","onEnd","disconnectedCallback","destroy","undefined","leftOptions","rightOptions","disconnect","getOpenAmount","Promise","resolve","getSlidingRatio","getSlidingRatioSync","open","side","_a","optionsToOpen","getOptions","isStartOpen","isEndOpen","closeOpened","requestAnimationFrame","calculateOptsWidth","width","setOpenAmount","close","options","querySelectorAll","i","length","option","componentOnReady","rtl","document","dir","atEdge","window","innerWidth","startX","selected","tmr","clearTimeout","style","transition","deltaX","Math","max","min","console","warn","optsWidth","velocity","velocityX","restingPoint","isResetDirection","isMovingFast","abs","isOnCloseZone","swipeShouldReset","fireSwipeEvent","display","offsetWidth","isFinal","setTimeout","transform","emit","amount","ratio","render","mode","class","watchers","isOnResetZone","defineCustomElement$1","customElements","components","forEach","tagName","get","define","IonItemSliding","defineCustomElement"],"sources":["C:/Users/EdinÃ©ia/Documents/NutriFood/node_modules/@ionic/core/components/ion-item-sliding.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';\nimport { w as watchForOptions } from './watch-options.js';\nimport { b as getIonMode } from './ionic-global.js';\nimport { a as findClosestIonContent, d as disableContentScrollY, r as resetContentScrollY } from './index8.js';\nimport { o as isEndSide } from './helpers.js';\n\nconst itemSlidingCss = \"ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item-sliding .item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.item-sliding-active-slide .item{position:relative;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;-ms-flex-order:1;order:1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-left;transition-property:padding-left}:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-end .item-options-end .item-option-expandable:dir(rtl){-ms-flex-order:-1;order:-1}}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;-ms-flex-order:-1;order:-1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-right;transition-property:padding-right}:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-start .item-options-start .item-option-expandable:dir(rtl){-ms-flex-order:1;order:1}}\";\n\nconst SWIPE_MARGIN = 30;\nconst ELASTIC_FACTOR = 0.55;\nlet openSlidingItem;\nconst ItemSliding = /*@__PURE__*/ proxyCustomElement(class ItemSliding extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionDrag = createEvent(this, \"ionDrag\", 7);\n    this.item = null;\n    this.openAmount = 0;\n    this.initialOpenAmount = 0;\n    this.optsWidthRightSide = 0;\n    this.optsWidthLeftSide = 0;\n    this.sides = 0 /* ItemSide.None */;\n    this.optsDirty = true;\n    this.contentEl = null;\n    this.initialContentScrollY = true;\n    this.state = 2 /* SlidingState.Disabled */;\n    this.disabled = false;\n  }\n  disabledChanged() {\n    if (this.gesture) {\n      this.gesture.enable(!this.disabled);\n    }\n  }\n  async connectedCallback() {\n    const { el } = this;\n    this.item = el.querySelector('ion-item');\n    this.contentEl = findClosestIonContent(el);\n    await this.updateOptions();\n    this.mutationObserver = watchForOptions(el, 'ion-item-option', async () => {\n      await this.updateOptions();\n    });\n    this.gesture = (await import('./index2.js')).createGesture({\n      el,\n      gestureName: 'item-swipe',\n      gesturePriority: 100,\n      threshold: 5,\n      canStart: (ev) => this.canStart(ev),\n      onStart: () => this.onStart(),\n      onMove: (ev) => this.onMove(ev),\n      onEnd: (ev) => this.onEnd(ev),\n    });\n    this.disabledChanged();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n    this.item = null;\n    this.leftOptions = this.rightOptions = undefined;\n    if (openSlidingItem === this.el) {\n      openSlidingItem = undefined;\n    }\n    if (this.mutationObserver) {\n      this.mutationObserver.disconnect();\n      this.mutationObserver = undefined;\n    }\n  }\n  /**\n   * Get the amount the item is open in pixels.\n   */\n  getOpenAmount() {\n    return Promise.resolve(this.openAmount);\n  }\n  /**\n   * Get the ratio of the open amount of the item compared to the width of the options.\n   * If the number returned is positive, then the options on the right side are open.\n   * If the number returned is negative, then the options on the left side are open.\n   * If the absolute value of the number is greater than 1, the item is open more than\n   * the width of the options.\n   */\n  getSlidingRatio() {\n    return Promise.resolve(this.getSlidingRatioSync());\n  }\n  /**\n   * Open the sliding item.\n   *\n   * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.\n   */\n  async open(side) {\n    var _a;\n    /**\n     * It is possible for the item to be added to the DOM\n     * after the item-sliding component was created. As a result,\n     * if this.item is null, then we should attempt to\n     * query for the ion-item again.\n     * However, if the item is already defined then\n     * we do not query for it again.\n     */\n    const item = (this.item = (_a = this.item) !== null && _a !== void 0 ? _a : this.el.querySelector('ion-item'));\n    if (item === null) {\n      return;\n    }\n    const optionsToOpen = this.getOptions(side);\n    if (!optionsToOpen) {\n      return;\n    }\n    /**\n     * If side is not set, we need to infer the side\n     * so we know which direction to move the options\n     */\n    if (side === undefined) {\n      side = optionsToOpen === this.leftOptions ? 'start' : 'end';\n    }\n    // In RTL we want to switch the sides\n    side = isEndSide(side) ? 'end' : 'start';\n    const isStartOpen = this.openAmount < 0;\n    const isEndOpen = this.openAmount > 0;\n    /**\n     * If a side is open and a user tries to\n     * re-open the same side, we should not do anything\n     */\n    if (isStartOpen && optionsToOpen === this.leftOptions) {\n      return;\n    }\n    if (isEndOpen && optionsToOpen === this.rightOptions) {\n      return;\n    }\n    this.closeOpened();\n    this.state = 4 /* SlidingState.Enabled */;\n    requestAnimationFrame(() => {\n      this.calculateOptsWidth();\n      const width = side === 'end' ? this.optsWidthRightSide : -this.optsWidthLeftSide;\n      openSlidingItem = this.el;\n      this.setOpenAmount(width, false);\n      this.state = side === 'end' ? 8 /* SlidingState.End */ : 16 /* SlidingState.Start */;\n    });\n  }\n  /**\n   * Close the sliding item. Items can also be closed from the [List](./list).\n   */\n  async close() {\n    this.setOpenAmount(0, true);\n  }\n  /**\n   * Close all of the sliding items in the list. Items can also be closed from the [List](./list).\n   */\n  async closeOpened() {\n    if (openSlidingItem !== undefined) {\n      openSlidingItem.close();\n      openSlidingItem = undefined;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Given an optional side, return the ion-item-options element.\n   *\n   * @param side This side of the options to get. If a side is not provided it will\n   * return the first one available.\n   */\n  getOptions(side) {\n    if (side === undefined) {\n      return this.leftOptions || this.rightOptions;\n    }\n    else if (side === 'start') {\n      return this.leftOptions;\n    }\n    else {\n      return this.rightOptions;\n    }\n  }\n  async updateOptions() {\n    const options = this.el.querySelectorAll('ion-item-options');\n    let sides = 0;\n    // Reset left and right options in case they were removed\n    this.leftOptions = this.rightOptions = undefined;\n    for (let i = 0; i < options.length; i++) {\n      const item = options.item(i);\n      /**\n       * We cannot use the componentOnReady helper\n       * util here since we need to wait for all of these items\n       * to be ready before we set `this.sides` and `this.optsDirty`.\n       */\n      // eslint-disable-next-line custom-rules/no-component-on-ready-method\n      const option = item.componentOnReady !== undefined ? await item.componentOnReady() : item;\n      const side = isEndSide(option.side) ? 'end' : 'start';\n      if (side === 'start') {\n        this.leftOptions = option;\n        sides |= 1 /* ItemSide.Start */;\n      }\n      else {\n        this.rightOptions = option;\n        sides |= 2 /* ItemSide.End */;\n      }\n    }\n    this.optsDirty = true;\n    this.sides = sides;\n  }\n  canStart(gesture) {\n    /**\n     * If very close to start of the screen\n     * do not open left side so swipe to go\n     * back will still work.\n     */\n    const rtl = document.dir === 'rtl';\n    const atEdge = rtl ? window.innerWidth - gesture.startX < 15 : gesture.startX < 15;\n    if (atEdge) {\n      return false;\n    }\n    const selected = openSlidingItem;\n    if (selected && selected !== this.el) {\n      this.closeOpened();\n    }\n    return !!(this.rightOptions || this.leftOptions);\n  }\n  onStart() {\n    /**\n     * We need to query for the ion-item\n     * every time the gesture starts. Developers\n     * may toggle ion-item elements via *ngIf.\n     */\n    this.item = this.el.querySelector('ion-item');\n    const { contentEl } = this;\n    if (contentEl) {\n      this.initialContentScrollY = disableContentScrollY(contentEl);\n    }\n    openSlidingItem = this.el;\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (this.openAmount === 0) {\n      this.optsDirty = true;\n      this.state = 4 /* SlidingState.Enabled */;\n    }\n    this.initialOpenAmount = this.openAmount;\n    if (this.item) {\n      this.item.style.transition = 'none';\n    }\n  }\n  onMove(gesture) {\n    if (this.optsDirty) {\n      this.calculateOptsWidth();\n    }\n    let openAmount = this.initialOpenAmount - gesture.deltaX;\n    switch (this.sides) {\n      case 2 /* ItemSide.End */:\n        openAmount = Math.max(0, openAmount);\n        break;\n      case 1 /* ItemSide.Start */:\n        openAmount = Math.min(0, openAmount);\n        break;\n      case 3 /* ItemSide.Both */:\n        break;\n      case 0 /* ItemSide.None */:\n        return;\n      default:\n        console.warn('invalid ItemSideFlags value', this.sides);\n        break;\n    }\n    let optsWidth;\n    if (openAmount > this.optsWidthRightSide) {\n      optsWidth = this.optsWidthRightSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    }\n    else if (openAmount < -this.optsWidthLeftSide) {\n      optsWidth = -this.optsWidthLeftSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    }\n    this.setOpenAmount(openAmount, false);\n  }\n  onEnd(gesture) {\n    const { contentEl, initialContentScrollY } = this;\n    if (contentEl) {\n      resetContentScrollY(contentEl, initialContentScrollY);\n    }\n    const velocity = gesture.velocityX;\n    let restingPoint = this.openAmount > 0 ? this.optsWidthRightSide : -this.optsWidthLeftSide;\n    // Check if the drag didn't clear the buttons mid-point\n    // and we aren't moving fast enough to swipe open\n    const isResetDirection = this.openAmount > 0 === !(velocity < 0);\n    const isMovingFast = Math.abs(velocity) > 0.3;\n    const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);\n    if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {\n      restingPoint = 0;\n    }\n    const state = this.state;\n    this.setOpenAmount(restingPoint, true);\n    if ((state & 32 /* SlidingState.SwipeEnd */) !== 0 && this.rightOptions) {\n      this.rightOptions.fireSwipeEvent();\n    }\n    else if ((state & 64 /* SlidingState.SwipeStart */) !== 0 && this.leftOptions) {\n      this.leftOptions.fireSwipeEvent();\n    }\n  }\n  calculateOptsWidth() {\n    this.optsWidthRightSide = 0;\n    if (this.rightOptions) {\n      this.rightOptions.style.display = 'flex';\n      this.optsWidthRightSide = this.rightOptions.offsetWidth;\n      this.rightOptions.style.display = '';\n    }\n    this.optsWidthLeftSide = 0;\n    if (this.leftOptions) {\n      this.leftOptions.style.display = 'flex';\n      this.optsWidthLeftSide = this.leftOptions.offsetWidth;\n      this.leftOptions.style.display = '';\n    }\n    this.optsDirty = false;\n  }\n  setOpenAmount(openAmount, isFinal) {\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (!this.item) {\n      return;\n    }\n    const style = this.item.style;\n    this.openAmount = openAmount;\n    if (isFinal) {\n      style.transition = '';\n    }\n    if (openAmount > 0) {\n      this.state =\n        openAmount >= this.optsWidthRightSide + SWIPE_MARGIN\n          ? 8 /* SlidingState.End */ | 32 /* SlidingState.SwipeEnd */\n          : 8 /* SlidingState.End */;\n    }\n    else if (openAmount < 0) {\n      this.state =\n        openAmount <= -this.optsWidthLeftSide - SWIPE_MARGIN\n          ? 16 /* SlidingState.Start */ | 64 /* SlidingState.SwipeStart */\n          : 16 /* SlidingState.Start */;\n    }\n    else {\n      /**\n       * Item sliding cannot be interrupted\n       * while closing the item. If it did,\n       * it would allow the item to get into an\n       * inconsistent state where multiple\n       * items are then open at the same time.\n       */\n      if (this.gesture) {\n        this.gesture.enable(false);\n      }\n      this.tmr = setTimeout(() => {\n        this.state = 2 /* SlidingState.Disabled */;\n        this.tmr = undefined;\n        if (this.gesture) {\n          this.gesture.enable(!this.disabled);\n        }\n      }, 600);\n      openSlidingItem = undefined;\n      style.transform = '';\n      return;\n    }\n    style.transform = `translate3d(${-openAmount}px,0,0)`;\n    this.ionDrag.emit({\n      amount: openAmount,\n      ratio: this.getSlidingRatioSync(),\n    });\n  }\n  getSlidingRatioSync() {\n    if (this.openAmount > 0) {\n      return this.openAmount / this.optsWidthRightSide;\n    }\n    else if (this.openAmount < 0) {\n      return this.openAmount / this.optsWidthLeftSide;\n    }\n    else {\n      return 0;\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    return (h(Host, { class: {\n        [mode]: true,\n        'item-sliding-active-slide': this.state !== 2 /* SlidingState.Disabled */,\n        'item-sliding-active-options-end': (this.state & 8 /* SlidingState.End */) !== 0,\n        'item-sliding-active-options-start': (this.state & 16 /* SlidingState.Start */) !== 0,\n        'item-sliding-active-swipe-end': (this.state & 32 /* SlidingState.SwipeEnd */) !== 0,\n        'item-sliding-active-swipe-start': (this.state & 64 /* SlidingState.SwipeStart */) !== 0,\n      } }));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"disabled\": [\"disabledChanged\"]\n  }; }\n  static get style() { return itemSlidingCss; }\n}, [0, \"ion-item-sliding\", {\n    \"disabled\": [4],\n    \"state\": [32],\n    \"getOpenAmount\": [64],\n    \"getSlidingRatio\": [64],\n    \"open\": [64],\n    \"close\": [64],\n    \"closeOpened\": [64]\n  }]);\nconst swipeShouldReset = (isResetDirection, isMovingFast, isOnResetZone) => {\n  // The logic required to know when the sliding item should close (openAmount=0)\n  // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)\n  // and it ended up being too complicated to be written manually without errors\n  // so the truth table is attached below: (0=false, 1=true)\n  // isResetDirection | isMovingFast | isOnResetZone || shouldClose\n  //         0        |       0      |       0       ||    0\n  //         0        |       0      |       1       ||    1\n  //         0        |       1      |       0       ||    0\n  //         0        |       1      |       1       ||    0\n  //         1        |       0      |       0       ||    0\n  //         1        |       0      |       1       ||    1\n  //         1        |       1      |       0       ||    1\n  //         1        |       1      |       1       ||    1\n  // The resulting expression was generated by resolving the K-map (Karnaugh map):\n  return (!isMovingFast && isOnResetZone) || (isResetDirection && isMovingFast);\n};\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-item-sliding\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-item-sliding\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, ItemSliding);\n      }\n      break;\n  } });\n}\n\nconst IonItemSliding = ItemSliding;\nconst defineCustomElement = defineCustomElement$1;\n\nexport { IonItemSliding, defineCustomElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}